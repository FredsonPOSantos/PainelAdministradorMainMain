<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Status dos Roteadores - Rota Hotspot</title>
    <!-- [CORRIGIDO] O caminho para o CSS deve ser absoluto para o servidor backend (porta 3000) para funcionar com o servidor de desenvolvimento do frontend. -->
    <!-- [NOVO] Adiciona o ficheiro de utilitários para ter acesso às funções de formatação. Usando caminho absoluto para maior robustez. -->
    <script src="/js/utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <!-- [UNIFICADO] Adiciona a nova folha de estilos partilhada para as páginas de monitoramento. -->
    <link rel="stylesheet" href="/css/monitoring_styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Estilo para status de aviso (latência alta) */
        .status-badge.warning {
            background-color: #f59e0b; /* Amarelo/Laranja */
            color: #fff;
        }
        /* Estilo para status crítico (latência muito alta) */
        .status-badge.critical {
            background-color: #ea580c; /* Laranja Escuro/Vermelho */
            color: #fff;
        }
    </style>
</head>
<body>
    <a href="/admin_dashboard.html" class="back-button">
        <i class="fas fa-arrow-left"></i> Voltar
    </a>

    <button class="refresh-button" onclick="loadRouterStatus()">
        <i class="fas fa-sync-alt"></i> Atualizar
    </button>

    <div class="header">
        <h1><i class="fas fa-network-wired"></i> Status dos Roteadores</h1>
        <p>Monitoramento em tempo real</p>
    </div>

    <div id="routerGrid" class="router-grid">
        <div class="loading">
            <i class="fas fa-spinner fa-spin"></i> Carregando roteadores...
        </div>
    </div>

    <!-- [NOVO] Modal para selecionar a interface de monitoramento -->
    <div id="interfaceModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="closeInterfaceModal()">&times;</button>
            <h3 id="interfaceModalTitle">Selecionar Interface de Monitoramento</h3>
            <form id="interfaceForm">
                <input type="hidden" id="modalRouterId">
                <div id="interfaceList" class="interface-list">
                    <!-- Lista de interfaces será populada aqui -->
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn-secondary" onclick="closeInterfaceModal()">Cancelar</button>
                    <button type="submit" class="btn-primary">Salvar</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let updateInterval;
        let currentRouters = []; // [NOVO] Armazena os dados dos roteadores para acesso rápido
        let charts = {}; // [NOVO] Armazena as instâncias dos gráficos para atualização

        // [MODIFICADO] Carregar status dos roteadores com URL absoluta e autenticação
        async function loadRouterStatus() {
             // [NOVO] Adiciona animação ao ícone de atualizar
             const refreshIcon = document.querySelector('.refresh-button i');
             if(refreshIcon) refreshIcon.classList.add('fa-spin');

             try {
                 // A URL da API deve ser absoluta para o servidor backend na porta 3000.
                 const API_URL = `http://${window.location.hostname}:3000`;
                 const token = localStorage.getItem('adminToken');
 
                 if (!token) {
                     window.location.href = '/admin_login.html';
                     return;
                 }
 
                 const response = await fetch(`${API_URL}/api/monitoring/all-routers-status`, {
                     headers: { 'Authorization': `Bearer ${token}` }
                 });
 
                 if (!response.ok) {
                     const errorText = await response.text();
                     throw new Error(`Erro na API: ${response.status} ${response.statusText}. Detalhes: ${errorText}`);
                 }
 
                 const routers = await response.json();

                 // [NOVO] Ordena a lista de roteadores para mostrar 'online' primeiro.
                 routers.sort((a, b) => {
                     // 'online' vem antes de 'offline'
                     if (a.status === 'online' && b.status !== 'online') {
                         return -1; // a vem primeiro
                     }
                     if (a.status !== 'online' && b.status === 'online') {
                         return 1; // b vem primeiro
                     }
                     // Se ambos tiverem o mesmo status, ordena por nome alfabeticamente
                     return a.name.localeCompare(b.name);
                 });

                 // [REMOVIDO] A lógica de 'default_interface' foi removida pois a coluna não existe no banco de dados.
                 currentRouters = routers;
 
                 const grid = document.getElementById('routerGrid');
                 const newGridContent = document.createDocumentFragment();
 
                 // Destrói instâncias de gráficos antigos para evitar memory leaks e erros de renderização.
                 Object.values(charts).forEach(chart => {
                     if (typeof chart.destroy === 'function') {
                         chart.destroy();
                     }
                 });
                 charts = {};
 
                 // 1. Cria todos os novos elementos de card em memória (DocumentFragment)
                 routers.forEach(router => {
                     const card = createRouterCard(router);
                     newGridContent.appendChild(card);
                 });
 
                 // 2. Limpa o grid e anexa o novo conteúdo de uma só vez para evitar que o DOM seja modificado durante a renderização dos gráficos.
                 grid.innerHTML = '';
                 grid.appendChild(newGridContent);
 
                 // 3. Agora que todos os cards estão no DOM, renderiza os gráficos em paralelo.
                 await Promise.all(routers.map(router => renderOrUpdateChart(router)));
 
             } catch (error) {
                 console.error('Erro ao carregar roteadores:', error);
                 document.getElementById('routerGrid').innerHTML = `
                     <div class="loading" style="color: #ef4444;">
                         <i class="fas fa-exclamation-triangle"></i> Erro ao carregar dados: ${error.message}
                     </div>
                 `;
             }
             finally {
                 // [NOVO] Remove animação
                 if(refreshIcon) refreshIcon.classList.remove('fa-spin');
             }
        }

        // [NOVO] Funções para controlar o modal de interfaces
        function openInterfaceModal(routerId, event) {
            event.stopPropagation(); // Impede que o clique no ícone acione o clique no card

            const router = currentRouters.find(r => r.id === routerId);
            if (!router || !router.interfaces) return;

            document.getElementById('modalRouterId').value = routerId;
            document.getElementById('interfaceModalTitle').textContent = `Selecionar Interface para "${router.name}"`;

            const listDiv = document.getElementById('interfaceList');
            listDiv.innerHTML = '';

            const selectedInterface = localStorage.getItem(`selectedInterface_${routerId}`);

            router.interfaces.forEach(ifaceObj => {
                const checked = (ifaceObj.name === selectedInterface) ? 'checked' : '';
                const itemHtml = `
                    <label class="interface-item">
                        <input type="radio" name="selectedInterface" value="${ifaceObj.name}" ${checked}>
                        ${ifaceObj.name}
                    </label>
                `;
                listDiv.innerHTML += itemHtml;
            });

            document.getElementById('interfaceModal').classList.add('visible');
        }

        function closeInterfaceModal() {
            document.getElementById('interfaceModal').classList.remove('visible');
        }

        // [NOVO] Lógica para salvar a seleção do modal
        document.getElementById('interfaceForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const routerId = String(document.getElementById('modalRouterId').value); // [CORREÇÃO] Força string
            const selectedRadio = document.querySelector('input[name="selectedInterface"]:checked');
            
            if (selectedRadio) {
                // [DIAGNÓSTICO] Adiciona log para verificar a seleção
                const interfaceSelecionada = selectedRadio.value;
                console.log(`[DIAGNÓSTICO] Salvando interface para router ID '${routerId}': ${interfaceSelecionada}`);
                localStorage.setItem(`selectedInterface_${routerId}`, interfaceSelecionada);
            }

            closeInterfaceModal();
            loadRouterStatus(); // Recarrega os cards para refletir a mudança
        });

        // [MODIFICADO] Criar card do roteador para usar dados reais do InfluxDB
        function createRouterCard(router) { // [MODIFICADO] Cria o card e o container do gráfico de forma mais robusta
            const card = document.createElement('div');
            
            let statusClass = 'offline';
            let statusText = 'Offline';
            let pingClass = 'offline';
            
            // [MODIFICADO] Usa a latência retornada para determinar o status visual, se disponível
            if (router.status === 'online' || (router.latency !== null)) {
                if (router.latency !== null && router.latency > 200) { // Limite crítico (> 200ms)
                    statusClass = 'critical';
                    statusText = 'Online (Lento)';
                    pingClass = 'critical';
                } else if (router.latency !== null && router.latency >= 125) { // Limite de aviso (>= 125ms)
                    statusClass = 'warning';
                    statusText = 'Online';
                    pingClass = 'warning';
                } else {
                    statusClass = 'online';
                    statusText = 'Online';
                    pingClass = 'online';
                }
            }

            card.className = `router-card ${statusClass}`;
            card.onclick = () => {
                window.location.href = `/pages/router_dashboard.html#${router.id}`;
            };

            // [REFEITO] Estrutura do card simplificada para focar no essencial
            card.innerHTML = `
                ${router.status === 'online' ? `<i class="fas fa-cog settings-icon" onclick="openInterfaceModal(${router.id}, event)"></i>` : ''}
                <div class="router-header">
                    <div class="router-name">${router.name || 'N/A'}</div>
                    <div class="status-badge ${statusClass}">${statusText}</div>
                </div>

                <div class="router-sub-info">
                    <span><i class="fas fa-network-wired"></i> ${router.ip || 'N/A'}</span>
                    <span><i class="fas fa-users"></i> ${router.connected_clients} Clientes</span>
                    <span><i class="fas fa-tachometer-alt"></i> ${router.latency !== null ? router.latency + ' ms' : 'N/A'}</span>
                </div>
            `;

            // [NOVO] Cria o container do gráfico explicitamente e o anexa ao card
            const chartContainerDiv = document.createElement('div');
            chartContainerDiv.className = 'traffic-chart-container';
            chartContainerDiv.id = `chart-container-${router.id}`;
            card.appendChild(chartContainerDiv);


            return card;
        }

        // [NOVO] Função para renderizar ou atualizar o gráfico de tráfego
        async function renderOrUpdateChart(router) {
            const routerIdStr = String(router.id); // [CORREÇÃO] Garante ID como string
            // [MODIFICADO] Usa a interface do localStorage OU a default_interface vinda da API.
            let selectedInterface = localStorage.getItem(`selectedInterface_${routerIdStr}`);
            if (!selectedInterface && router.default_interface) {
                selectedInterface = router.default_interface;
                // Salva a interface padrão no localStorage para que a escolha seja mantida nas próximas atualizações.
                localStorage.setItem(`selectedInterface_${routerIdStr}`, selectedInterface);
            }

            const chartContainer = document.getElementById(`chart-container-${router.id}`);

            if (!selectedInterface || !chartContainer) {
                // Only update innerHTML if chartContainer is not null
                if (chartContainer) chartContainer.innerHTML = '<p style="text-align: center; color: #9ca3af; font-size: 0.9em; padding-top: 30px;">Selecione uma interface na <i class="fas fa-cog"></i> para ver o tráfego.</p>'; 
                return;
            }
            
            // console.log(`[FRONTEND] Renderizando gráfico para ${router.name} (${router.id}) usando interface: ${selectedInterface}`);

            try {
                const API_URL = `http://${window.location.hostname}:3000`;
                const token = localStorage.getItem('adminToken');
                const response = await fetch(`${API_URL}/api/monitoring/router/${router.id}/interface-traffic?interface=${encodeURIComponent(selectedInterface)}&range=15m`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!response.ok) throw new Error('Falha ao buscar dados de tráfego.');
                
                const result = await response.json();
                const trafficData = result.data;

                const series = [
                    { name: 'Download (RX)', data: trafficData.map(d => ({ x: new Date(d.time).getTime(), y: d.rx || 0 })) },
                    { name: 'Upload (TX)', data: trafficData.map(d => ({ x: new Date(d.time).getTime(), y: d.tx || 0 })) }
                ];

                const options = {
                    series: series,
                    chart: {
                        type: 'area',
                        height: 120,
                        sparkline: { enabled: false },
                        toolbar: { show: false },
                        animations: { enabled: true, easing: 'linear', dynamicAnimation: { speed: 500 } },
                        zoom: { enabled: false }
                    },
                    colors: ['#3498db', '#e74c3c'],
                    dataLabels: { enabled: false },
                    stroke: { curve: 'smooth', width: 2 },
                    fill: {
                        type: 'gradient',
                        gradient: {
                            shadeIntensity: 1,
                            opacityFrom: 0.4,
                            opacityTo: 0.1,
                            stops: [0, 100]
                        }
                    },
                    xaxis: {
                        type: 'datetime',
                        labels: { 
                            show: false,
                            datetimeUTC: false // [CORREÇÃO] Garante que o gráfico exiba a hora local, não UTC.
                        },
                        axisBorder: { show: false },
                        axisTicks: { show: false }
                    },
                    yaxis: {
                        labels: {
                            formatter: (value) => formatBitsPerSecond(value), // Usa a função global
                            style: {
                                colors: '#E5E7EB' // [NOVO] Define a cor do texto do eixo Y para ser visível no tema escuro.
                            }
                        }
                    },
                    tooltip: {
                        x: { format: 'HH:mm' },
                        y: { formatter: (value) => formatBitsPerSecond(value) }, // Garante que a função correta é chamada
                        theme: 'dark' // [NOVO] Garante que o tooltip seja legível no tema escuro.
                    },
                    legend: {
                        show: true,
                        position: 'top',
                        horizontalAlign: 'left',
                        fontSize: '10px',
                        markers: { width: 8, height: 8 },
                        labels: {
                            colors: '#E5E7EB' // [NOVO] Define a cor do texto da legenda.
                        }
                    },
                    grid: {
                        show: false,
                        padding: { left: 0, right: 0 }
                    },
                    // [NOVO] Define o tema geral do gráfico para garantir a consistência.
                    theme: { mode: 'dark' }
                };

                if (charts[router.id]) {
                    charts[router.id].updateOptions(options);
                } else {
                    charts[router.id] = new ApexCharts(chartContainer, options);
                    charts[router.id].render();
                }
            } catch (error) {
                console.error(`Erro ao renderizar gráfico para ${router.name}:`, error);
                chartContainer.innerHTML = `<p style="color: #ef4444; text-align: center;">Erro ao carregar gráfico.</p>`;
            }
        }

        // Inicializar
        loadRouterStatus();

        // Atualizar a cada 5 segundos
        updateInterval = setInterval(loadRouterStatus, 60000); // Aumentado para 60s para dar tempo de obter o ping

        // Limpar interval ao sair da página
        window.addEventListener('beforeunload', () => {
            clearInterval(updateInterval);
        });

        // [NOVO] Adiciona um listener para fechar o modal se clicar fora dele
        document.getElementById('interfaceModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeInterfaceModal();
            }
        });
    </script>
</body>
</html>